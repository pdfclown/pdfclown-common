/*
  SPDX-FileCopyrightText: © 2025 Stefano Chizzolini and contributors

  SPDX-License-Identifier: LGPL-3.0-only

  This file (Test.java) is part of pdfclown-common-build module in pdfClown Common project
  <https://github.com/pdfclown/pdfclown-common>

  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER. If you reuse (entirely or partially)
  this file, you MUST add your own copyright notice in a separate comment block above this file
  header, listing the main changes you applied to the original source.
 */
package org.pdfclown.common.build.test;

import static org.pdfclown.common.build.test.Tests.argumentsGenerator;

import java.io.UncheckedIOException;
import java.lang.reflect.UndeclaredThrowableException;
import java.util.List;
import java.util.function.Function;
import org.apache.commons.lang3.function.FailableSupplier;
import org.junit.jupiter.params.ParameterizedTest;
import org.pdfclown.common.build.test.Tests.ThrownExpected;

/**
 * Unit test.
 *
 * @author Stefano Chizzolini
 */
public abstract class Test extends TestUnit {
  /**
   * Asserts the actual value corresponds to the expected one.
   * <p>
   * Intended for use within {@linkplain ParameterizedTest parameterized tests}, to check both valid
   * and invalid (ie, {@link Exception}) results in a unified and consistent manner.
   * </p>
   *
   * @param actual
   *          Result of {@link #evalParameterized(FailableSupplier)}.
   * @param expected
   *          Expected result (provided by {@link Tests#argumentsStream(List, List...)} and
   *          generated by {@link #generateExpected(Object, List, List)}).
   * @apiNote For usage example, see {@link Tests#assertParameterized(Object, Object)}.
   */
  protected void assertParameterized(Object actual, Object expected) {
    Tests.assertParameterized(actual, expected);
  }

  /**
   * Evaluates the given expression.
   * <p>
   * Intended for use within {@linkplain ParameterizedTest parameterized tests}; its result is
   * expected to be checked via {@link #assertParameterized(Object, Object)}.
   * </p>
   *
   * @return The result of {@code expression}, or its thrown exception (unchecked exceptions
   *         ({@link UncheckedIOException}, {@link UndeclaredThrowableException}) are unwrapped).
   * @apiNote For usage example, see {@link Tests#assertParameterized(Object, Object)}.
   */
  protected Object evalParameterized(FailableSupplier<Object, Exception> expression) {
    return Tests.evalParameterized(expression);
  }

  /**
   * Design-time utility to generate the source code representation of the expected result for
   * {@linkplain Tests#argumentsStream(List, List...) parameterized test feeding}.
   * <p>
   * The expected result is mapped to source code representation via
   * {@code expectedSourceCodeGenerator}; {@link Throwable} is mapped to {@link ThrownExpected}. The
   * resulting representation is sent to {@linkplain System#err stderr}.
   * </p>
   *
   * @param expected
   *          Expected result.
   * @param expectedSourceCodeGenerator
   *          Generates the source code representation of {@code expected}.
   * @param argNames
   *          Argument names.
   * @param args
   *          Argument values.
   * @apiNote For more information, see {@link Tests#argumentsStream(List, List...)} — NOTE: You
   *          should prefer this simplified method to
   *          {@code Tests.argumentsGenerator().generateExpectedOf(..)} described in the "Argument
   *          generation" paragraph therein.
   */
  protected <T> void generateExpected(T expected, Function<T, String> expectedSourceCodeGenerator,
      List<String> argNames, List<?> args) {
    argumentsGenerator().generateExpectedOf(System.err, expected, expectedSourceCodeGenerator,
        argNames, args);
  }

  /**
   * Design-time utility to generate the source code representation of the expected result for
   * {@linkplain Tests#argumentsStream(List, List...) parameterized test feeding}.
   * <p>
   * The expected result is mapped to source code representation based on its value type:
   * </p>
   * <ul>
   * <li>primitive values and strings are mapped to their literal</li>
   * <li>{@link Throwable} is mapped to {@link ThrownExpected}</li>
   * <li>any other type is mapped to literal string — to customize its representation, use
   * {@link #generateExpected(Object, Function, List, List)} instead</li>
   * </ul>
   * <p>
   * The resulting representation is sent to {@linkplain System#err stderr}.
   * </p>
   *
   * @param expected
   *          Expected result.
   * @param argNames
   *          Argument names.
   * @param args
   *          Argument values.
   * @apiNote For more information, see {@link Tests#argumentsStream(List, List...)} — NOTE: You
   *          should prefer this simplified method to
   *          {@code Tests.argumentsGenerator().generateExpectedOf(..)} described in the "Argument
   *          generation" paragraph therein.
   */
  protected <T> void generateExpected(T expected, List<String> argNames, List<?> args) {
    argumentsGenerator().generateExpectedOf(System.err, expected, argNames, args);
  }
}
