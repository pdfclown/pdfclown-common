/*
  SPDX-FileCopyrightText: © 2025 Stefano Chizzolini and contributors

  SPDX-License-Identifier: LGPL-3.0-only

  This file (Executions.java) is part of pdfclown-common-build module in pdfClown Common project
  <https://github.com/pdfclown/pdfclown-common>

  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER. If you reuse (entirely or partially)
  this file, you MUST add your own copyright notice in a separate comment block above this file
  header, listing the main changes you applied to the original source.
 */
package org.pdfclown.common.build.test.assertion;

import static java.nio.charset.StandardCharsets.UTF_8;
import static org.pdfclown.common.build.internal.util_.Exceptions.wrongArg;

import java.io.ByteArrayOutputStream;
import java.io.PrintStream;
import java.util.ArrayList;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutionException;
import org.apache.commons.lang3.mutable.MutableObject;
import org.jspecify.annotations.NonNull;
import org.jspecify.annotations.Nullable;

/**
 * Execution utilities.
 *
 * @author Stefano Chizzolini
 */
public final class Executions {
  /**
   * Synchronously executes tasks in parallel, canceling all of them in case an exception occurs.
   *
   * @param tasks
   *          Operations to execute.
   * @throws ExecutionException
   *           if any of the tasks fails to execute.
   */
  public static void failFast(@NonNull Runnable... tasks)
      throws ExecutionException, InterruptedException {
    var futures = new ArrayList<CompletableFuture<Void>>();
    var failure = new CompletableFuture<Void>().exceptionally($ex -> {
      futures.forEach($ -> $.cancel(true));
      //noinspection DataFlowIssue
      return null;
    });
    for (var task : tasks) {
      futures.add(CompletableFuture.runAsync(task).exceptionally($ex -> {
        failure.completeExceptionally($ex);
        return null;
      }));
    }
    CompletableFuture
        .anyOf(failure, CompletableFuture.allOf(futures.toArray(CompletableFuture[]::new)))
        .get();
  }

  /**
   * Executes a task, returning its output from {@link System#err stderr}.
   * <p>
   * <span class="important">IMPORTANT: If {@code task} fails, its exception is propagated to the
   * calling stack, preventing this method from returning the generated output. If you need to get
   * it whatever happens to the task, call
   * {@link #interceptSystemStreams(Runnable, MutableObject, MutableObject, boolean)}
   * instead.</span>
   * </p>
   *
   * @param task
   *          Operation to execute.
   * @return {@link System#err stderr} output generated by {@code task}.
   * @implNote The output is diverted from {@link System#err stderr}, temporarily replacing its
   *           default implementation with ad-hoc one.
   */
  public static synchronized String interceptSystemErr(Runnable task) {
    var errRef = new MutableObject<String>();
    interceptSystemStreams(task, null, errRef, false);
    return errRef.getValue();
  }

  /**
   * Executes a task and returns its output from {@link System#out stdout}.
   * <p>
   * <span class="important">IMPORTANT: If {@code task} fails, its exception is propagated to the
   * calling stack, preventing this method from returning the generated output. If you need to get
   * it whatever happens to the task, call
   * {@link #interceptSystemStreams(Runnable, MutableObject, MutableObject, boolean)}
   * instead.</span>
   * </p>
   *
   * @param task
   *          Operation to execute.
   * @return {@link System#out stdout} output generated by {@code task}.
   * @implNote The output is diverted from {@link System#out stdout}, temporarily replacing its
   *           default implementation with ad-hoc one.
   */
  public static synchronized String interceptSystemOut(Runnable task) {
    var outRef = new MutableObject<String>();
    interceptSystemStreams(task, outRef, null, false);
    return outRef.getValue();
  }

  /**
   * Executes a task and returns its output from the standard streams (both {@link System#out
   * stdout} and {@link System#err stderr}).
   * <p>
   * <span class="important">IMPORTANT: If {@code task} fails, its exception is propagated to the
   * calling stack, preventing this method from returning the generated output. If you need to get
   * it whatever happens to the task, call
   * {@link #interceptSystemStreams(Runnable, MutableObject, MutableObject, boolean)}
   * instead.</span>
   * </p>
   *
   * @param task
   *          Operation to execute.
   * @return Standard streams' output generated by {@code task}.
   * @implNote The output is diverted from the standard streams, temporarily replacing their default
   *           implementations with ad-hoc ones.
   */
  public static synchronized String interceptSystemStreams(Runnable task) {
    var outRef = new MutableObject<String>();
    interceptSystemStreams(task, outRef, null, true);
    return outRef.getValue();
  }

  // SPDX-SnippetBegin
  // SPDX-SnippetCopyrightText: © 2016-2022 Talsma ICT
  // SPDX-License-Identifier: Apache-2.0
  //
  // Source: https://github.com/talsma-ict/umldoclet/blob/a1776aa4b3c9af1b073c31969721e867233fe727/src/test/java/nl/talsmasoftware/umldoclet/issues/Issue267Test.java
  // SourceName: nl.talsmasoftware.umldoclet.issues.Issue267Test.interceptSystemOut
  // Changes: adaptation to pdfClown
  /**
   * Executes a task, intercepting the output from the standard streams.
   *
   * @param task
   *          Operation to execute.
   * @param outRef
   *          (out) Intercepted stdout output ({@code null}, to avoid its interception).
   * @param errRef
   *          (out) Intercepted stderr output ({@code null}, to avoid its interception).
   * @param merged
   *          Whether the output of both standard streams has to be merged into a single result (in
   *          this case, both {@code outRef} and {@code errRef} are filled with the same value).
   * @implNote The output is diverted from the standard streams, temporarily replacing their default
   *           implementations with ad-hoc ones.
   */
  public static synchronized void interceptSystemStreams(Runnable task,
      @Nullable MutableObject<String> outRef, @Nullable MutableObject<String> errRef,
      boolean merged) {
    if (outRef == null) {
      if (errRef == null)
        throw wrongArg("At least one among `outRef` and `errRef` MUST be defined");
      else if (merged) {
        outRef = new MutableObject<>();
      }
    }

    ByteArrayOutputStream outStream = null;
    ByteArrayOutputStream errStream = null;
    PrintStream oldOut = null;
    PrintStream oldErr = null;
    final var charset = UTF_8;
    try {
      PrintStream out = null;
      if (outRef != null) {
        oldOut = System.out;

        System.setOut(out = new PrintStream(outStream = new ByteArrayOutputStream(), true,
            charset));
      }
      if (errRef != null || merged) {
        oldErr = System.err;

        System.setErr(merged ? out
            : new PrintStream(errStream = new ByteArrayOutputStream(), true, charset));
      }

      task.run();
    } finally {
      if (oldOut != null) {
        try {
          assert outStream != null;
          outRef.setValue(outStream.toString(charset));
        } finally {
          System.setOut(oldOut);
        }
      }
      if (oldErr != null) {
        try {
          if (errRef != null) {
            assert errStream != null;
            //noinspection ConstantValue
            errRef.setValue(merged ? outRef.getValue() : errStream.toString(charset));
          }
        } finally {
          System.setErr(oldErr);
        }
      }
    }
  }
  // SPDX-SnippetEnd

  private Executions() {
  }
}
