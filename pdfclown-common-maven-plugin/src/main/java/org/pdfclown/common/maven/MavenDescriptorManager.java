/*
  SPDX-FileCopyrightText: Â© 2025 Stefano Chizzolini and contributors

  SPDX-License-Identifier: LGPL-3.0-or-later

  This file (MavenDescriptorManager.java) is part of pdfclown-common-maven-plugin module in pdfClown
  Common project <https://github.com/pdfclown/pdfclown-common>

  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER. If you reuse (entirely or partially)
  this file, you MUST add your own copyright notice in a separate comment block above this file
  header, listing the main changes you applied to the original source.
 */
package org.pdfclown.common.maven;

import static org.pdfclown.common.maven.MavenDescriptorMojo.CONTEXT_KEY__MAVEN_DESCRIPTOR;
import static org.pdfclown.common.maven.Util.PLUGIN_KEY__PDFCLOWN_COMMON;
import static org.pdfclown.common.maven.Util.pluginTag;
import static org.pdfclown.common.maven.util.MavenModels.PACKAGING__POM;
import static org.pdfclown.common.util.Exceptions.runtime;
import static org.pdfclown.common.util.Exceptions.wrongState;
import static org.pdfclown.common.util.Strings.COLON;
import static org.pdfclown.common.util.Strings.EMPTY;

import java.io.File;
import java.util.function.Predicate;
import org.apache.commons.lang3.stream.Streams;
import org.apache.maven.model.Plugin;
import org.apache.maven.model.PluginExecution;
import org.apache.maven.plugin.MojoExecution;
import org.apache.maven.plugins.annotations.LifecyclePhase;
import org.apache.maven.project.MavenProject;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Manages the injection of the normalized Maven descriptor generated by {@link MavenDescriptorMojo}
 * into the build process.
 *
 * @author Stefano Chizzolini
 */
class MavenDescriptorManager {
  private static final Logger log = LoggerFactory.getLogger(MavenDescriptorManager.class);

  private static final String CONTEXT_KEY__ORIGINAL_PROJECT_POM =
      PLUGIN_KEY__PDFCLOWN_COMMON + COLON + "originalMavenDescriptor";

  public void onMojoEnd(MavenProject project) {
    restoreOriginalMavenDescriptor(project);
  }

  /**
   * @implNote Replaces {@code project}'s POM file with the corresponding normalized Maven
   *           descriptor for publishing purposes, if the goal execution matches the inclusion
   *           filter; in order not to disrupt the build session (some goals (eg,
   *           {@code surefire:test}) may inspect the project POM during their execution), the
   *           original project POM is restored {@link #onMojoEnd(MavenProject) on execution
   *           ending}. This hack is necessary as standard Maven plugins (such as
   *           {@code maven-gpg-plugin}, {@code maven-install-plugin}, {@code maven-deploy-plugin})
   *           use raw project POM files ({@code pom.xml}) as published metadata.
   */
  public void onMojoStart(MavenProject project, MojoExecution execution) {
    var normalMavenDescriptorGoalFilter = (Predicate<String>) project.getContextValue(
        MavenDescriptorMojo.CONTEXT_KEY__NORMAL_MAVEN_DESCRIPTOR_GOAL_FILTER);
    // Goal execution non-eligible for POM replacement?
    if (normalMavenDescriptorGoalFilter == null
        // Goal not covered by POM replacement?
        || !normalMavenDescriptorGoalFilter.test(execution.getArtifactId() + COLON
            + execution.getGoal())
        // Normalized maven descriptor already applied to the project?
        || project.getContextValue(CONTEXT_KEY__ORIGINAL_PROJECT_POM) != null)
      return;

    applyNormalMavenDescriptor(project);
  }

  public void onProjectStart(MavenProject project) {
    checkMavenDescriptorMojoExecution(project);
  }

  /**
   * Replaces the project POM with the normalized Maven descriptor for metadata publishing!
   * <p>
   * The project POM is used by several Maven plugins (including standard ones such as
   * {@code maven-install-plugin}) as artifact descriptor; in order to force them to use the
   * normalized Maven descriptor instead, we have to temporarily assign it as project POM.
   * </p>
   *
   * @see #restoreOriginalMavenDescriptor(MavenProject)
   */
  private void applyNormalMavenDescriptor(MavenProject project) {
    var normalMavenDescriptorFile = (File) project.getContextValue(CONTEXT_KEY__MAVEN_DESCRIPTOR);
    if (normalMavenDescriptorFile == null)
      throw wrongState("Normalized maven descriptor undefined");

    // Temporarily store the original POM file as context value!
    project.setContextValue(CONTEXT_KEY__ORIGINAL_PROJECT_POM, project.getFile());

    log.info("[{}] Replacing project POM ({}) with normalized maven descriptor ({}) "
        + "for metadata publishing.", pluginTag(project), project.getFile(),
        normalMavenDescriptorFile);
    log.info(EMPTY);

    // Replace project POM with normalized descriptor!
    project.setFile(normalMavenDescriptorFile);
  }

  /**
   * Checks that {@link MavenDescriptorMojo} execution is properly defined.
   */
  private void checkMavenDescriptorMojoExecution(MavenProject project) {
    Plugin pdfclownPlugin = project.getPlugin(PLUGIN_KEY__PDFCLOWN_COMMON);
    /*
     * NOTE: Even if it's our running plugin, it may be undefined in the current project, so we have
     * to check it.
     */
    if (pdfclownPlugin != null) {
      if (!project.getPackaging().equals(PACKAGING__POM)) {
        PluginExecution mavenDescriptorMojoExecution = null;
        for (PluginExecution execution : pdfclownPlugin.getExecutions()) {
          if (execution.getGoals().contains(MavenDescriptorMojo.NAME)) {
            /*
             * NOTE: Undefined phase means default phase (ie, execution enabled), whilst defined
             * phase needs to be evaluated.
             */
            if (execution.getPhase() != null) {
              LifecyclePhase phase = Streams.of(LifecyclePhase.values())
                  .filter($ -> $.id().equals(execution.getPhase()))
                  .findFirst().orElse(null);
              if (phase == null) {
                /*
                 * NOTE: Unknown phase means the execution is disabled.
                 */
                continue;
              }

              if (phase.compareTo(MavenDescriptorMojo.DEFAULT_PHASE) > 0)
                throw runtime("Illegal phase ({}) for `{}:{}` goal execution "
                    + "(MUST be prior or equal to '{}')", execution.getPhase(), pluginTag(project),
                    MavenDescriptorMojo.NAME, MavenDescriptorMojo.DEFAULT_PHASE.id());
            }

            if (mavenDescriptorMojoExecution != null)
              throw runtime("Multiple `{}:{}` goal executions detected (CAN be executed only "
                  + "once)", pluginTag(project), MavenDescriptorMojo.NAME);

            mavenDescriptorMojoExecution = execution;
          }
        }
      }
    }
  }

  /**
   * Restores the original project POM.
   * <p>
   * If the original project POM is stored as context value, it was temporarily replaced with the
   * normalized Maven descriptor; therefore, we have to restore it.
   * </p>
   *
   * @see #applyNormalMavenDescriptor(MavenProject)
   */
  private void restoreOriginalMavenDescriptor(MavenProject project) {
    var originalProjectPomFile = (File) project.getContextValue(CONTEXT_KEY__ORIGINAL_PROJECT_POM);
    if (originalProjectPomFile == null)
      return;

    if (log.isDebugEnabled()) {
      log.debug("[{}] Restoring project POM ({}).", pluginTag(project), originalProjectPomFile);
    }

    /*
     * Restore the original project POM!
     *
     * NOTE: If the original project POM is saved as context value, it was replaced with the
     * normalized Maven descriptor; therefore, we have to restore it when goal execution ends.
     */
    project.setFile(originalProjectPomFile);
    project.setContextValue(CONTEXT_KEY__ORIGINAL_PROJECT_POM, null);
  }
}
